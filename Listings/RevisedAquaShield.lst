C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE REVISEDAQUASHIELD
OBJECT MODULE PLACED IN .\Objects\RevisedAquaShield.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE RevisedAquaShield.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\RevisedAquaShield.lst) TABS(2) OBJECT(.\Objects\RevisedAquaShield.obj)

line level    source

   1          #include <reg51.h>
   2          
   3          #define NUMBER "+9779815007805"        //Here insert your number where you want to send message
   4          #define LCD_data P0
   5          
   6          // Rain detection controlling bits
   7          sbit R1 = P3^2;
   8          sbit R2 = P3^3;
   9          sbit R3 = P3^4;
  10          
  11          //DC motor control bits
  12          
  13          sbit clock = P2^3;
  14          sbit anticlock = P2^4;
  15          
  16          // LCD control bits
  17          sbit RS = P2^0;
  18          sbit RW = P2^1;
  19          sbit EN = P2^2;
  20          
  21          // Rain condition bits
  22          sbit rain_condition = P3^7;
  23          
  24          // Debug pin
  25          sbit DebugPin = P3^5;
  26          
  27          // GSM Initialization
  28          void sim_init();
  29          void tx(unsigned char send);
  30          void tx_string(unsigned char *s);
  31          void sms(unsigned char *num1, unsigned char *msg);
  32          void delay(unsigned int ms);
  33          
  34          // LCD Initialization
  35          void LCD_cmd(unsigned char command);
  36          void LCD_data_write(unsigned char dataa);
  37          void LCD_init(void);
  38          void LCD_off(void);
  39          void LCD_string_write(unsigned char *string);
  40          
  41          //Motor Initialization
  42          void motor_clockwise(void);
  43          void motor_anticlockwise(void);
  44            
  45          // Idle Mode Initialization
  46          void initTimer0(void);
  47          void enterIdleMode(void);
  48          
  49          // Timer variable
  50          unsigned long timer_count_60sec = 0;
  51          
  52          // Add a flag for timer completion
  53          bit timer_complete = 0;
  54          bit timer_running = 0;  // New flag to track timer status
C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 2   

  55          
  56          // Timer Module
  57          void timer0_isr(void) interrupt 1
  58          {
  59   1          TF0 = 0;        // Clear timer flag
  60   1          
  61   1          // Reload timer values for 50ms interval at 11.0592MHz
  62   1          TH0 = 0x4B;
  63   1          TL0 = 0xFE;
  64   1          DebugPin = !DebugPin;
  65   1      
  66   1          
  67   1          timer_count_60sec++;
  68   1          if (timer_count_60sec >= 40) { // 50ms * 1200 = 60 seconds
  69   2              timer_complete = 1;  // Set flag when timer completes
  70   2              timer_running = 0;   // Update timer status
  71   2              TR0 = 0;             // Stop timer
  72   2              timer_count_60sec = 0;
  73   2          }
  74   1      }
  75          
  76          
  77          //Motor control functions
  78          void motor_clockwise(void)
  79          {
  80   1          clock = 1;
  81   1          anticlock = 0;
  82   1      }
  83          
  84          void motor_anticlockwise(void)
  85          {
  86   1          clock = 0;
  87   1          anticlock = 1;
  88   1      }
  89          
  90          void motor_stop(void)
  91          {
  92   1          clock = 0;
  93   1          anticlock = 0;
  94   1      }
  95          
  96          void initTimer0(void)
  97          {
  98   1          // Initialize Timer0 for 50ms intervals
  99   1          TMOD = (TMOD & 0xF0) | 0x01;  // Preserve Timer1 settings, set Timer0 to mode 1
 100   1          TH0 = 0x4B;     // Initial value for 50ms at 11.0592MHz
 101   1          TL0 = 0xFE;
 102   1          ET0 = 1;        // Enable Timer0interrupt
 103   1          timer_count_60sec = 0;
 104   1          timer_complete = 0;     // Reset the timer completion flag
 105   1          timer_running = 1;      // Set timer running flag
 106   1          TR0 = 1;        // Start timer
 107   1      }
 108          
 109          void enterIdleMode(void)
 110          {
 111   1          // Ensure interrupts are enabled before entering idle mode
 112   1          EA = 1;
 113   1          if (timer_running) {
 114   2              PCON |= 0x01;   // Enter idle mode only if timer is running
 115   2              // After this instruction, CPU operation is suspended until aninterrupt
 116   2              // When a timerinterrupt occurs, CPU wakes up and execution continues
C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 3   

 117   2              // from the next instruction after this function call
 118   2          }
 119   1      }
 120          
 121          void main()
 122          {
 123   1          // Initialize global interrupts
 124   1          EA = 1;
 125   1          
 126   1          // Initialize motor pins
 127   1          clock = 0;
 128   1          anticlock = 0;
 129   1          
 130   1          // Initial LCD display
 131   1          LCD_init();
 132   1          LCD_cmd(0x80);  // First line
 133   1          LCD_string_write("System Ready");
 134   1          delay(50);
 135   1          LCD_cmd(0x01);
 136   1          LCD_off();
 137   1          
 138   1          while(1) {
 139   2              if (rain_condition == 1) {  // It's not raining
 140   3                  
 141   3                  // Check rain sensors - more lenient detection (any sensor triggers)
 142   3                  if (R1 == 0 || R2 == 0 || R3 == 0) {
 143   4                      // Rain is detected
 144   4                      rain_condition = 0;
 145   4                      
 146   4                      LCD_init();
 147   4                      
 148   4                      LCD_cmd(0x80);  // First line
 149   4                      LCD_string_write("Rain Detected!");
 150   4                      delay(50);
 151   4                      LCD_cmd(0x01);  // Clear display
 152   4                      LCD_off();
 153   4      
 154   4                      // Retrieve clothes (rotate clockwise)
 155   4                      motor_clockwise();
 156   4                      delay(100);  // Run motor for 5 seconds - increased for visibility
 157   4                      motor_stop();
 158   4      
 159   4                      sim_init();
 160   4                      sms(NUMBER, "Clothes Retrieved");
 161   4                      
 162   4                      // LCD Module
 163   4                      LCD_init();
 164   4                      LCD_cmd(0xC0);  // Second line
 165   4                      LCD_string_write("Clothes Retrieved");
 166   4                      delay(50);
 167   4                      LCD_cmd(0x01);  // Clear display
 168   4                      LCD_off();
 169   4                  } else {
 170   4                      LCD_off();
 171   4                  }
 172   3                  
 173   3                  // Start 60-second timer and enter idle mode
 174   3                  initTimer0();
 175   3                  
 176   3                  while (!timer_complete) {
 177   4                      enterIdleMode();  // System enters low-power mode here
 178   4                      
C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 4   

 179   4                      // ? EXECUTION PAUSES HERE UNTIL AN INTERRUPT OCCURS ?
 180   4                      
 181   4                      // When Timer0 generates aninterrupt (every 50ms):
 182   4                      // 1. The CPU wakes up and executes timer0_isr()
 183   4                      // 2. After the ISR completes, execution CONTINUES FROM HERE
 184   4                      
 185   4                      // Loop returns to enterIdleMode() and CPU sleeps again
 186   4                  }
 187   3                  
 188   3                  // Display timer complete
 189   3                  if (timer_complete) {
 190   4                    LCD_init();
 191   4                    LCD_cmd(0x01);  // Clear display
 192   4                    LCD_cmd(0x80);
 193   4                    LCD_string_write("Timer Complete!");
 194   4                    delay(10);
 195   4                    LCD_cmd(0x01);  // Clear display
 196   4                    LCD_off();
 197   4                  }
 198   3                  
 199   3                  
 200   3              } else {  // It's raining
 201   3                  
 202   3                  
 203   3                  // Check rain sensors after timer completes
 204   3                  if (R1 == 1 && R2 == 1 && R3 == 1) {
 205   4                      // No rain detected
 206   4                      rain_condition = 1; // It's not raining now
 207   4      
 208   4                      // Release clothes (rotate anti-clockwise)
 209   4                      motor_anticlockwise();
 210   4                      delay(100);  // Run motor for some time
 211   4                      motor_stop();
 212   4      
 213   4                      sim_init();
 214   4                      sms(NUMBER, "Clothes Released");
 215   4                     
 216   4      
 217   4                      // LCD Module
 218   4                      LCD_init();
 219   4                      LCD_cmd(0x01);  // Clear display
 220   4                      LCD_cmd(0xC0);
 221   4                      LCD_string_write("Clothes Released");
 222   4                      delay(50);
 223   4                      LCD_cmd(0x01);  // Clear display
 224   4                      LCD_off();
 225   4                  }
 226   3                  // Start 60-second timer and enter idle mode
 227   3                  initTimer0();
 228   3                  
 229   3                  while (!timer_complete) {
 230   4                      enterIdleMode();  // System will wake on timerinterrupt
 231   4                    
 232   4                  }
 233   3                  
 234   3                  // Display timer complete
 235   3                  if (timer_complete) {
 236   4                    LCD_init();
 237   4                    LCD_cmd(0x01);  // Clear display
 238   4                    LCD_cmd(0x80);
 239   4                    LCD_string_write("Timer Complete!");
 240   4                    delay(10);
C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 5   

 241   4                    LCD_cmd(0x01);  // Clear display
 242   4                    LCD_off();
 243   4                  }
 244   3                  
 245   3              }
 246   2          }
 247   1      }
 248          
 249          // GSM Module Function Declaration
 250          void delay(unsigned int ms) {
 251   1          unsigned int i, j;
 252   1          for(i = 0; i < ms; i++)
 253   1              for(j = 0; j < 1275; j++);
 254   1        
 255   1      }void sim_init()
 256          {
 257   1          SCON=0X50;    //0101 0000 
 258   1          TMOD=0X20;      //FOR AUTO RELOAD MODE OF TIMER 1   0010 0000
 259   1          TH1=0XFD; //FOR 9600 BAUD RATE OF THE MICROCONTROLLER
 260   1          TL1=0XFD; //load the value of high time
 261   1          TR1=1;  //START TIMER
 262   1      }
 263          
 264          void tx(unsigned char send)
 265          {
 266   1          SBUF = send;
 267   1          while(TI==0);
 268   1          TI=0;   //reset the timer interrupt
 269   1      
 270   1      }
 271          
 272          void tx_string(unsigned char *s)
 273          {
 274   1          while(*s)
 275   1              tx(*s++);
 276   1      }
 277          
 278          void sms(unsigned char *num1, unsigned char *msg)
 279          {
 280   1          tx_string("AT");
 281   1          tx(0x0d); 
 282   1          //tx(0x0a);  // Try both CR and LF
 283   1          delay(100);
 284   1      
 285   1          tx_string("AT+CMGF=1");
 286   1          tx(0x0d); //tx(0x0a);
 287   1          delay(100);
 288   1        
 289   1          tx_string("AT+CMGS=");
 290   1          tx('"');
 291   1          tx_string(num1);
 292   1          tx('"');
 293   1          tx(0x0d); 
 294   1          delay(100); // Increase if needed
 295   1      
 296   1          // Ideally, wait here for '>' prompt from SIM800L
 297   1      
 298   1        tx_string(msg);
 299   1          tx(0x1A); // CTRL+Z to send
 300   1          delay(100); // Wait for SMS send to complete
 301   1      }
 302          
C51 COMPILER V9.60.7.0   REVISEDAQUASHIELD                                                 06/20/2025 07:42:39 PAGE 6   

 303          // LCD Module Function Declaration
 304          
 305          void LCD_off(void){
 306   1      LCD_cmd(0x08);
 307   1      }
 308          void LCD_cmd(unsigned char command) {
 309   1          LCD_data = command;
 310   1          RS = 0;
 311   1          RW = 0;
 312   1          EN = 1;
 313   1          delay(10);
 314   1          EN = 0;
 315   1      }
 316          
 317          void LCD_data_write(unsigned char dataa) {
 318   1          LCD_data = dataa;
 319   1          RS = 1;
 320   1          RW = 0;
 321   1          EN = 1;
 322   1          EN = 0;
 323   1      }
 324          
 325          void LCD_init(void) {
 326   1          LCD_cmd(0x38); // 2-line, 5x7 font
 327   1        delay(10);
 328   1          LCD_cmd(0x0E); // Display ON, Cursor ON
 329   1        delay(10);
 330   1          LCD_cmd(0x01); // Clear display
 331   1      }
 332          
 333          void LCD_string_write(unsigned char *string) {
 334   1          while (*string != '\0') {
 335   2              LCD_data_write(*string++);
 336   2          }
 337   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    787    ----
   CONSTANT SIZE    =    116    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      4      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
